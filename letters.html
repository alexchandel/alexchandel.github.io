<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#ffffff" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <title>Flash Cards</title>
  <style>
    :root { color-scheme: light dark; }
    html, body { height: 100%; margin: 0; }
    body {
      display: flex;
      align-items: center;
      justify-content: center;
      background: #fff;
      color: #000;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      -webkit-tap-highlight-color: transparent;
      touch-action: pan-y;
      user-select: none;
      overflow: hidden;
    }
    @media (prefers-color-scheme: dark) {
      body { background: #000; color: #fff; }
    }

    #card {
      width: 100vw;
      height: 100vh;
      display: grid;
      place-items: center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
      text-align: center;
      line-height: 1;
      will-change: transform;
    }
    #glyph {
      font-size: min(56vw, 56vh);
      font-weight: 700;
      letter-spacing: 0.02em;
      padding: 0.1em;
    }

    #hud {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px 14px calc(10px + env(safe-area-inset-bottom));
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 14px;
      opacity: 0.78;
      -webkit-user-select: none;
      user-select: none;
    }

    .pill {
      border: 1px solid rgba(0,0,0,0.15);
      border-radius: 999px;
      padding: 6px 10px;
      background: rgba(255,255,255,0.85);
      color: #000;
      backdrop-filter: blur(6px);
    }
    @media (prefers-color-scheme: dark) {
      .pill {
        border-color: rgba(255,255,255,0.2);
        background: rgba(0,0,0,0.65);
        color: #fff;
      }
    }
    button.pill {
      font: inherit;
      cursor: pointer;
    }
    button.pill:active { transform: translateY(1px); }

    /* Jump menu modal */
    #modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: stretch;
      justify-content: center;
      background: rgba(0,0,0,0.35);
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      box-sizing: border-box;
      -webkit-user-select: none;
      user-select: none;
    }
    #modal.open { display: flex; }

    #sheet {
      width: min(720px, 100%);
      height: min(720px, 100%);
      margin: auto;
      border-radius: 16px;
      overflow: hidden;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.92);
      color: #000;
      backdrop-filter: blur(10px);
      display: grid;
      grid-template-rows: auto auto 1fr;
    }
    @media (prefers-color-scheme: dark) {
      #sheet {
        border-color: rgba(255,255,255,0.2);
        background: rgba(0,0,0,0.78);
        color: #fff;
      }
    }
    #sheetHeader {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
    }
    @media (prefers-color-scheme: dark) {
      #sheetHeader { border-bottom-color: rgba(255,255,255,0.16); }
    }
    #sheetTitle { font-weight: 600; }
    #closeBtn { padding: 6px 10px; }

    #catBar {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(0,0,0,0.12);
    }
    @media (prefers-color-scheme: dark) {
      #catBar { border-bottom-color: rgba(255,255,255,0.16); }
    }
    .chip {
      border-radius: 999px;
      padding: 6px 10px;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.7);
      cursor: pointer;
      font-size: 14px;
      white-space: nowrap;
    }
    .chip.active {
      font-weight: 700;
      background: rgba(255,255,255,0.95);
    }
    @media (prefers-color-scheme: dark) {
      .chip { border-color: rgba(255,255,255,0.2); background: rgba(0,0,0,0.4); }
      .chip.active { background: rgba(0,0,0,0.8); }
    }

    #grid {
      padding: 10px 12px 14px;
      overflow: auto;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
      gap: 10px;
      align-content: start;
    }
    .cell {
      aspect-ratio: 1 / 1;
      border-radius: 12px;
      border: 1px solid rgba(0,0,0,0.12);
      background: rgba(255,255,255,0.7);
      display: grid;
      place-items: center;
      cursor: pointer;
      font-size: 34px;
      line-height: 1;
    }
    @media (prefers-color-scheme: dark) {
      .cell { border-color: rgba(255,255,255,0.16); background: rgba(0,0,0,0.45); }
    }
    .cell:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div id="card" aria-label="Flash card">
    <div id="glyph" aria-live="polite"></div>
  </div>

  <div id="hud">
    <div style="display:flex; gap:10px; align-items:center;">
      <button class="pill" id="jumpBtn" title="Jump">Jump</button>
      <div class="pill" id="pos">1 / 1</div>
    </div>
    <button class="pill" id="shuffleBtn" title="Shuffle">Shuffle</button>
  </div>

  <div id="modal" role="dialog" aria-modal="true" aria-label="Jump menu">
    <div id="sheet">
      <div id="sheetHeader">
        <div id="sheetTitle">Jump</div>
        <button class="pill" id="closeBtn">Close</button>
      </div>
      <div id="catBar"></div>
      <div id="grid"></div>
    </div>
  </div>

<script>
(() => {
  // ---------------- Deck ----------------
  const deckSpec = [];
  function addMany(category, items) { for (const t of items) deckSpec.push({ t, c: category }); }

  addMany("ABC", [..."ABCDEFGHIJKLMNOPQRSTUVWXYZ"]);
  addMany("abc", [..."abcdefghijklmnopqrstuvwxyz"]);
  addMany("123", [..."0123456789"]);
  addMany("Symbols", ["â˜…","â™¥","â—","â– ","â–²","â—†","â˜€ï¸","â˜ï¸","â˜‚ï¸","â˜•ï¸","â™«","âœ“","âœš","âœ–ï¸","âž•","âž–","â­•ï¸","âŒ"]);

  addMany("Animals", [
    "ðŸ¶","ðŸ±","ðŸ¦","ðŸ¯","ðŸ»","ðŸ¼","ðŸ¨","ðŸ¸","ðŸµ","ðŸ°","ðŸ¦Š","ðŸ®","ðŸ·","ðŸ”","ðŸ¤","ðŸ¦†","ðŸ¦‰",
    "ðŸ´","ðŸ¦„","ðŸ","ðŸž","ðŸ¦‹","ðŸ¢","ðŸ™","ðŸ ","ðŸ¬","ðŸ¦ˆ","ðŸ¦€","ðŸ¦–"
  ]);

  addMany("Food", ["ðŸŽ","ðŸŒ","ðŸ“","ðŸ‡","ðŸ‰","ðŸ¥•","ðŸ¥¦","ðŸž","ðŸ§€","ðŸ¥š","ðŸª","ðŸ¼","ðŸ¥›"]);
  addMany("Vehicles", ["ðŸš—","ðŸš•","ðŸšŒ","ðŸš‘","ðŸš’","ðŸšœ","ðŸšš","ðŸš²","ðŸ›´","ðŸš€","âœˆï¸"]);

  addMany("Home", [
    "ðŸ“š","ðŸ§¸","ðŸª€","ðŸ§©","ðŸŽˆ","ðŸ–ï¸","âœï¸","ðŸ§¼","ðŸª¥","ðŸ›","ðŸš½","ðŸ§»","ðŸ›ï¸","ðŸª‘","ðŸ›‹ï¸",
    "ðŸšª","ðŸªŸ","ðŸ’¡","ðŸ”‘","ðŸ“¦","ðŸ§º","ðŸ§´","ðŸ½ï¸","ðŸ¥„","ðŸ´","ðŸ§ƒ",
    "â°","âŒšï¸","ðŸ“±","ðŸ”Œ","ðŸ“º","ðŸŽµ","ðŸ””"
  ]);

  addMany("Faces", ["ðŸ˜€","ðŸ™‚","ðŸ˜®","ðŸ˜´","ðŸ¥³","ðŸ˜¢","ðŸ˜¡","ðŸ˜†"]);

  // ---------------- State / Render ----------------
  let deck = deckSpec.slice();
  let i = 0;

  // Restore starting card from URL hash.
  // Supports:
  //   #12   -> 0-based index 12
  //   #A    -> jump to first matching glyph "A"
  //   #ðŸ¦   -> jump to first matching emoji "ðŸ¦"
  (function applyInitialHash() {
    const raw = (location.hash || "").slice(1);
    if (!raw) return;

    // If it's an integer, treat it as a 0-based index.
    if (/^\d+$/.test(raw)) {
      i = parseInt(raw, 10) || 0;
      return;
    }

    // Otherwise treat as a glyph (may include percent-encoding).
    let glyph = raw;
    try { glyph = decodeURIComponent(raw); } catch (_) {}

    const idx = deck.findIndex(x => x.t === glyph);
    if (idx >= 0) i = idx;
  })();

  let activeCategory = "All";

  const cardEl = document.getElementById("card");
  const glyphEl = document.getElementById("glyph");
  const posEl = document.getElementById("pos");
  const jumpBtn = document.getElementById("jumpBtn");
  const shuffleBtn = document.getElementById("shuffleBtn");

  const modal = document.getElementById("modal");
  const closeBtn = document.getElementById("closeBtn");
  const catBar = document.getElementById("catBar");
  const grid = document.getElementById("grid");

  function clampIndex(idx) {
    const n = deck.length || 1;
    return ((idx % n) + n) % n;
  }

  function render() {
    if (!deck.length) {
      glyphEl.textContent = "â€”";
      posEl.textContent = "0 / 0";
      return;
    }
    i = clampIndex(i);
    glyphEl.textContent = deck[i].t;
    posEl.textContent = `${i + 1} / ${deck.length}`;
    history.replaceState(null, "", `#${i}`);
  }

  function next() { i++; render(); }
  function prev() { i--; render(); }

  function shuffleInPlace(arr) {
    for (let j = arr.length - 1; j > 0; j--) {
      const k = Math.floor(Math.random() * (j + 1));
      [arr[j], arr[k]] = [arr[k], arr[j]];
    }
  }

  function shuffleDeck() {
    const current = deck[i];
    shuffleInPlace(deck);
    i = Math.max(0, deck.findIndex(x => x.t === current.t && x.c === current.c));
    render();
    if (modal.classList.contains("open")) buildGrid();
  }

  // ---------------- Keyboard (desktop) ----------------
  window.addEventListener("keydown", (e) => {
    if (e.key === "Escape") { if (modal.classList.contains("open")) closeModal(); return; }
    if (modal.classList.contains("open")) return;

    if (e.key === "ArrowRight" || e.key === " " || e.key === "PageDown") { e.preventDefault(); next(); }
    else if (e.key === "ArrowLeft" || e.key === "PageUp") { e.preventDefault(); prev(); }
    else if (e.key.toLowerCase() === "s") { shuffleDeck(); }
    else if (e.key.toLowerCase() === "j") { openModal(); }
  }, { passive: false });

  // ---------------- Horizontal spring drag ----------------
  // We implement our own horizontal drag while allowing vertical scroll bounce.
  // Drag beyond threshold => advance/back. Otherwise snap back.
  let dragging = false;
  let startX = 0, startY = 0;
  let dx = 0;
  let lockedAxis = null; // "x" or "y" or null
  const LOCK_ANGLE_TOL = 10; // px: initial ambiguity tolerance
  const SWIPE_THRESHOLD = () => Math.min(140, Math.max(80, window.innerWidth * 0.22)); // adaptive
  const RESIST_EDGE = 0.35; // resistance when dragging far

  function setTranslate(x) {
    cardEl.style.transform = `translateX(${x}px)`;
  }

  function springBack() {
    cardEl.style.transition = "transform 180ms cubic-bezier(0.2, 0.8, 0.2, 1)";
    setTranslate(0);
    window.setTimeout(() => { cardEl.style.transition = ""; }, 200);
  }

  function commitSwipe(dir /* -1 prev, +1 next */) {
    // Small slide-out then swap then slide back in (subtle; still not "fancy")
    const outX = dir * -Math.min(180, window.innerWidth * 0.28);
    cardEl.style.transition = "transform 120ms ease-out";
    setTranslate(outX);

    window.setTimeout(() => {
      cardEl.style.transition = "";
      setTranslate(0);
      if (dir === 1) next(); else prev();
    }, 130);
  }

  window.addEventListener("touchstart", (e) => {
    if (modal.classList.contains("open")) return;
    if (!e.touches || e.touches.length !== 1) return;

    dragging = true;
    lockedAxis = null;
    dx = 0;

    const t = e.touches[0];
    startX = t.clientX;
    startY = t.clientY;
  }, { passive: true });

  window.addEventListener("touchmove", (e) => {
    if (!dragging || modal.classList.contains("open")) return;
    if (!e.touches || e.touches.length !== 1) return;

    const t = e.touches[0];
    const curX = t.clientX;
    const curY = t.clientY;

    const rawDx = curX - startX;
    const rawDy = curY - startY;

    // Decide whether this gesture is horizontal or vertical early on.
    if (lockedAxis === null) {
      if (Math.abs(rawDx) < LOCK_ANGLE_TOL && Math.abs(rawDy) < LOCK_ANGLE_TOL) return;
      lockedAxis = (Math.abs(rawDx) > Math.abs(rawDy)) ? "x" : "y";
    }

    if (lockedAxis === "y") {
      // Let the browser handle vertical scroll/bounce.
      return;
    }

    // Horizontal: prevent back/forward navigation and scroll.
    e.preventDefault();

    // Resistance: as you pull further, movement dampens slightly.
    const sign = Math.sign(rawDx);
    const adx = Math.abs(rawDx);
    const resisted = sign * (adx < 120 ? adx : 120 + (adx - 120) * RESIST_EDGE);
    dx = resisted;

    setTranslate(dx);
  }, { passive: false });

  window.addEventListener("touchend", (e) => {
    if (!dragging) return;
    dragging = false;

    if (lockedAxis !== "x") {
      // If it was vertical or never decided, do nothing special.
      dx = 0;
      lockedAxis = null;
      return;
    }

    const threshold = SWIPE_THRESHOLD();
    if (dx <= -threshold) {
      // dragged left => next
      commitSwipe(1);
    } else if (dx >= threshold) {
      // dragged right => prev
      commitSwipe(-1);
    } else {
      springBack();
    }

    dx = 0;
    lockedAxis = null;
  }, { passive: true });

  window.addEventListener("touchcancel", () => {
    if (!dragging) return;
    dragging = false;
    springBack();
    dx = 0;
    lockedAxis = null;
  }, { passive: true });

  // ---------------- Jump Menu ----------------
  function openModal() {
    modal.classList.add("open");
    buildCategoryBar();
    buildGrid();
  }
  function closeModal() { modal.classList.remove("open"); }

  jumpBtn.addEventListener("click", openModal);
  closeBtn.addEventListener("click", closeModal);
  shuffleBtn.addEventListener("click", shuffleDeck);

  modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

  function categories() {
    const set = new Set(deckSpec.map(x => x.c));
    return ["All", ...Array.from(set)];
  }

  function buildCategoryBar() {
    catBar.innerHTML = "";
    for (const c of categories()) {
      const b = document.createElement("button");
      b.className = "chip" + (c === activeCategory ? " active" : "");
      b.textContent = c;
      b.addEventListener("click", () => {
        activeCategory = c;
        buildCategoryBar();
        buildGrid();
      });
      catBar.appendChild(b);
    }
  }

  function filteredIndices() {
    const idxs = [];
    for (let k = 0; k < deck.length; k++) {
      if (activeCategory === "All" || deck[k].c === activeCategory) idxs.push(k);
    }
    return idxs;
  }

  function buildGrid() {
    grid.innerHTML = "";
    const idxs = filteredIndices();
    for (const k of idxs) {
      const cell = document.createElement("div");
      cell.className = "cell";
      cell.textContent = deck[k].t;
      cell.title = `${deck[k].c}`;
      cell.addEventListener("click", () => {
        i = k;
        render();
        closeModal();
      });
      grid.appendChild(cell);
    }
  }

  render();

  // ---- One-file PWA: manifest + service worker ----
  const manifest = {
    name: "Flash Cards",
    short_name: "ðŸ¦ Cards",
    start_url: "./",
    display: "standalone",
    background_color: "#ffffff",
    theme_color: "#ffffff",
    icons: [
      {
        src: "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='512' height='512'%3E%3Crect width='100%25' height='100%25' fill='white'/%3E%3Ctext x='50%25' y='58%25' text-anchor='middle' font-size='320'%3E%F0%9F%A6%81%3C/text%3E%3C/svg%3E",
        sizes: "512x512",
        type: "image/svg+xml",
        purpose: "any"
      }
    ]
  };

  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: "application/manifest+json" });
  const manifestURL = URL.createObjectURL(manifestBlob);
  const link = document.createElement("link");
  link.rel = "manifest";
  link.href = manifestURL;
  document.head.appendChild(link);

  if ("serviceWorker" in navigator) {
    const swCode = `
      const CACHE = "flashcards-v3";
      self.addEventListener("install", (e) => {
        e.waitUntil((async () => {
          const cache = await caches.open(CACHE);
          await cache.addAll(["./", "./index.html"]);
          self.skipWaiting();
        })());
      });
      self.addEventListener("activate", (e) => {
        e.waitUntil((async () => {
          const keys = await caches.keys();
          await Promise.all(keys.map(k => (k === CACHE ? null : caches.delete(k))));
          self.clients.claim();
        })());
      });
      self.addEventListener("fetch", (e) => {
        e.respondWith((async () => {
          const cached = await caches.match(e.request, { ignoreSearch: true });
          return cached || fetch(e.request);
        })());
      });
    `;
    const swBlob = new Blob([swCode], { type: "text/javascript" });
    const swURL = URL.createObjectURL(swBlob);
    navigator.serviceWorker.register(swURL).catch(() => {});
  }
})();
</script>
</body>
</html>
